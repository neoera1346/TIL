# State Control

## The Importance of the State

### Greater in the Front-end Development

---

## **State : UI에 동적으로 표현될 데이터**

쿠팡의 장바구니 웹페이지를 예시로, 상태는 어떤 것들인지 확인해보자.

1. "장바구니에 담기"

   - 해당 물품을 장바구니에 추가하게 되며, 데이터가 동적으로 변한다.

2. 상단에 [일반구매/정기배송] 중 현재 선택된 탭

3. 상품 선택 여부에 따라 주문 금액이나 배송비가 달라지는 것.

4. 상품 수량
   - 3번과 동일한 이유

---

## Side Effect

Side Effect : 함수(또는 컴포넌트)의 입력 외에도 함수의 결과에 영향을 미치는 요인이다.

- 대표적인 예 : 네트워크 요청 (백엔드 API 요청)

기본적으로 순수 함수는, 외부 요인에 영향을 받지 않는 함수이다. 그러나, 이 함수에 전역에 선언된 변수가 들어간다면 순수 함수가 아니다. 입력값 이외에도 내부에 사용되는 변수에 따라 출력값이 변하기 때문이다. 그래서 순수함수는 '입력'이라는 구멍과, '출력'이라는 구멍 두 가지뿐이다.

fetch나 실제 데이터 없이 컴포넌트를 만들 수 있는데, 이 때 Side Effect를 최대한 배제하고 컴포넌트를 만드는 것이 좋다.

또한 만약, 위에 예시로 언급했던 장바구니의 데이터가 서버에 있다면, 네트워크 요청(fetch) 때문에 오래 걸릴 수도 있다. 이 때 사용되는 '데이터 로딩 여부'(isLoading)은 Side-Effect에 의존적이다.

---

## Isolating States

상태를 구분하는 데에는 절대적인 기준이나 법칙이 있는 것은 아니지만 일반적으로 `로컬 상태`와 `전역 상태` 두 가지로 나뉜다.

`로컬 상태`는 보통 컴포넌트 내에서만 영향을 끼친다. 다시 장바구니의 카트 단일 목록을 보면, '선택한 수량'이 바로 로컬 상태다. 원래 가격에 해당 상태를 곱해 컴포넌트 내에 표시되는 주문 금액을 업데이트하면 되기 때문이다.

이처럼, 다른 컴포넌트와 데이터를 공유하지 않는 폼(form) 데이터는 대부분 로컬 상태인데, 추가 예시로, `input box`, `select box`가 있다.

`전역 상태`는 다른 컴포넌트와 상태를 공유하고 영향을 끼치는 상태이다. 장바구니에 담긴 물품의 경우, 상품 선택 여부에 따라 총 주문 금액을 업데이트해야 한다.

서로 다른 컴포넌트가 사용하는 상태가 다르다면 서로 다른 출처가 있어도 상관 없다. 그러나 A Component와 B Component 모두 동일한 상태를 다룰 때는 동일한 출처를 사용해야 한다.

이를 '데이터 무결성'이라고 부른다. 무결성을 위한 방법론은 "Single Source of Truth"라는 것이 있는데, 동일한 데이터는 항상 같은 곳에서 데이터를 가지고 온다는 의미이다.

전역관리 상태의 예시

- Light & Dark Mode 테마 설정
- 언어 설정 (Globalization)
- Undo/Redo를 위한 History 기능

---

## Tools for State Control

아래의 상태 관리 툴들은 '전역 상태 저장소'를 제공해주고, Props Drilling 이슈를 해결해준다.

- React Context
- Redux
- MobX
